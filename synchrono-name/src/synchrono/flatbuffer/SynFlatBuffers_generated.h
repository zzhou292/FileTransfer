// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace SynFlatBuffers {
namespace SPAT {

struct State;

struct Lane;

}  // namespace SPAT

struct Vector;

struct Quaternion;

struct Pose;

namespace MAP {

struct State;

struct Lane;

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

struct State;

}  // namespace TrafficLight

namespace Vehicle {

struct State;

}  // namespace Vehicle

struct State;

}  // namespace Agent

namespace Interface {

struct State;

struct Camera;

struct Lidar;

struct GPS;

struct IMU;

struct Control;

struct Time;

struct Exit;

}  // namespace Interface

namespace SCM {

struct State;

struct Node;

}  // namespace SCM

namespace Sensor {
namespace Camera {

struct RGBA8;

struct R8;

}  // namespace Camera

namespace Lidar {

struct XYZI;

struct DI;

}  // namespace Lidar

namespace IMU {

struct Vec;

struct IMUData;

}  // namespace IMU

namespace GPS {

struct GPSData;

}  // namespace GPS

struct SensorBuffer;

struct State;

}  // namespace Sensor

struct Buffer;

struct Message;

struct Pointer;

namespace SPAT {

enum Color {
  Color_Green = 0,
  Color_Yellow = 1,
  Color_Red = 2,
  Color_MIN = Color_Green,
  Color_MAX = Color_Red
};

inline const Color (&EnumValuesColor())[3] {
  static const Color values[] = {
    Color_Green,
    Color_Yellow,
    Color_Red
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[4] = {
    "Green",
    "Yellow",
    "Red",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (e < Color_Green || e > Color_Red) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

}  // namespace SPAT

namespace Agent {

enum Type {
  Type_NONE = 0,
  Type_Vehicle_State = 1,
  Type_TrafficLight_State = 2,
  Type_MIN = Type_NONE,
  Type_MAX = Type_TrafficLight_State
};

inline const Type (&EnumValuesType())[3] {
  static const Type values[] = {
    Type_NONE,
    Type_Vehicle_State,
    Type_TrafficLight_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[4] = {
    "NONE",
    "Vehicle_State",
    "TrafficLight_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_TrafficLight_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Vehicle::State> {
  static const Type enum_value = Type_Vehicle_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrafficLight::State> {
  static const Type enum_value = Type_TrafficLight_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Agent

namespace Interface {

enum Type {
  Type_NONE = 0,
  Type_Camera = 1,
  Type_Lidar = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_Control = 5,
  Type_Time = 6,
  Type_Exit = 7,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Exit
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type_NONE,
    Type_Camera,
    Type_Lidar,
    Type_GPS,
    Type_IMU,
    Type_Control,
    Type_Time,
    Type_Exit
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "NONE",
    "Camera",
    "Lidar",
    "GPS",
    "IMU",
    "Control",
    "Time",
    "Exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Exit) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Exit> {
  static const Type enum_value = Type_Exit;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Interface

namespace Sensor {

enum Type {
  Type_Camera_RGBA8 = 0,
  Type_Camera_R8 = 1,
  Type_Lidar_DI = 2,
  Type_Lidar_XYZI = 3,
  Type_IMU_IMUData = 4,
  Type_GPS_GPSData = 5,
  Type_MIN = Type_Camera_RGBA8,
  Type_MAX = Type_GPS_GPSData
};

inline const Type (&EnumValuesType())[6] {
  static const Type values[] = {
    Type_Camera_RGBA8,
    Type_Camera_R8,
    Type_Lidar_DI,
    Type_Lidar_XYZI,
    Type_IMU_IMUData,
    Type_GPS_GPSData
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[7] = {
    "Camera_RGBA8",
    "Camera_R8",
    "Lidar_DI",
    "Lidar_XYZI",
    "IMU_IMUData",
    "GPS_GPSData",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_Camera_RGBA8 || e > Type_GPS_GPSData) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace Sensor

enum Type {
  Type_NONE = 0,
  Type_Pointer = 1,
  Type_Agent_State = 2,
  Type_Interface_State = 3,
  Type_SPAT_State = 4,
  Type_MAP_State = 5,
  Type_SCM_State = 6,
  Type_Sensor_State = 7,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Sensor_State
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type_NONE,
    Type_Pointer,
    Type_Agent_State,
    Type_Interface_State,
    Type_SPAT_State,
    Type_MAP_State,
    Type_SCM_State,
    Type_Sensor_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "NONE",
    "Pointer",
    "Agent_State",
    "Interface_State",
    "SPAT_State",
    "MAP_State",
    "SCM_State",
    "Sensor_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Sensor_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Pointer> {
  static const Type enum_value = Type_Pointer;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::State> {
  static const Type enum_value = Type_Agent_State;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::State> {
  static const Type enum_value = Type_Interface_State;
};

template<> struct TypeTraits<SynFlatBuffers::SPAT::State> {
  static const Type enum_value = Type_SPAT_State;
};

template<> struct TypeTraits<SynFlatBuffers::MAP::State> {
  static const Type enum_value = Type_MAP_State;
};

template<> struct TypeTraits<SynFlatBuffers::SCM::State> {
  static const Type enum_value = Type_SCM_State;
};

template<> struct TypeTraits<SynFlatBuffers::Sensor::State> {
  static const Type enum_value = Type_Sensor_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

namespace Sensor {
namespace Camera {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) RGBA8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t R_;
  int8_t G_;
  int8_t B_;
  int8_t A_;

 public:
  RGBA8() {
    memset(static_cast<void *>(this), 0, sizeof(RGBA8));
  }
  RGBA8(int8_t _R, int8_t _G, int8_t _B, int8_t _A)
      : R_(flatbuffers::EndianScalar(_R)),
        G_(flatbuffers::EndianScalar(_G)),
        B_(flatbuffers::EndianScalar(_B)),
        A_(flatbuffers::EndianScalar(_A)) {
  }
  int8_t R() const {
    return flatbuffers::EndianScalar(R_);
  }
  int8_t G() const {
    return flatbuffers::EndianScalar(G_);
  }
  int8_t B() const {
    return flatbuffers::EndianScalar(B_);
  }
  int8_t A() const {
    return flatbuffers::EndianScalar(A_);
  }
};
FLATBUFFERS_STRUCT_END(RGBA8, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) R8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t R_;

 public:
  R8() {
    memset(static_cast<void *>(this), 0, sizeof(R8));
  }
  R8(int8_t _R)
      : R_(flatbuffers::EndianScalar(_R)) {
  }
  int8_t R() const {
    return flatbuffers::EndianScalar(R_);
  }
};
FLATBUFFERS_STRUCT_END(R8, 1);

}  // namespace Camera

namespace Lidar {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) XYZI FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float intensity_;

 public:
  XYZI() {
    memset(static_cast<void *>(this), 0, sizeof(XYZI));
  }
  XYZI(float _x, float _y, float _z, float _intensity)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        intensity_(flatbuffers::EndianScalar(_intensity)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
};
FLATBUFFERS_STRUCT_END(XYZI, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DI FLATBUFFERS_FINAL_CLASS {
 private:
  float range_;
  float intensity_;

 public:
  DI() {
    memset(static_cast<void *>(this), 0, sizeof(DI));
  }
  DI(float _range, float _intensity)
      : range_(flatbuffers::EndianScalar(_range)),
        intensity_(flatbuffers::EndianScalar(_intensity)) {
  }
  float range() const {
    return flatbuffers::EndianScalar(range_);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
};
FLATBUFFERS_STRUCT_END(DI, 8);

}  // namespace Lidar

namespace IMU {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vec FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  Vec() {
    memset(static_cast<void *>(this), 0, sizeof(Vec));
  }
  Vec(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IMUData FLATBUFFERS_FINAL_CLASS {
 private:
  SynFlatBuffers::Sensor::IMU::Vec Accel_;
  double Roll_;
  double Pitch_;
  double Yaw_;

 public:
  IMUData() {
    memset(static_cast<void *>(this), 0, sizeof(IMUData));
  }
  IMUData(const SynFlatBuffers::Sensor::IMU::Vec &_Accel, double _Roll, double _Pitch, double _Yaw)
      : Accel_(_Accel),
        Roll_(flatbuffers::EndianScalar(_Roll)),
        Pitch_(flatbuffers::EndianScalar(_Pitch)),
        Yaw_(flatbuffers::EndianScalar(_Yaw)) {
  }
  const SynFlatBuffers::Sensor::IMU::Vec &Accel() const {
    return Accel_;
  }
  double Roll() const {
    return flatbuffers::EndianScalar(Roll_);
  }
  double Pitch() const {
    return flatbuffers::EndianScalar(Pitch_);
  }
  double Yaw() const {
    return flatbuffers::EndianScalar(Yaw_);
  }
};
FLATBUFFERS_STRUCT_END(IMUData, 48);

}  // namespace IMU

namespace GPS {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) GPSData FLATBUFFERS_FINAL_CLASS {
 private:
  double Latitude_;
  double Longitude_;
  double Altitude_;
  double Time_;

 public:
  GPSData() {
    memset(static_cast<void *>(this), 0, sizeof(GPSData));
  }
  GPSData(double _Latitude, double _Longitude, double _Altitude, double _Time)
      : Latitude_(flatbuffers::EndianScalar(_Latitude)),
        Longitude_(flatbuffers::EndianScalar(_Longitude)),
        Altitude_(flatbuffers::EndianScalar(_Altitude)),
        Time_(flatbuffers::EndianScalar(_Time)) {
  }
  double Latitude() const {
    return flatbuffers::EndianScalar(Latitude_);
  }
  double Longitude() const {
    return flatbuffers::EndianScalar(Longitude_);
  }
  double Altitude() const {
    return flatbuffers::EndianScalar(Altitude_);
  }
  double Time() const {
    return flatbuffers::EndianScalar(Time_);
  }
};
FLATBUFFERS_STRUCT_END(GPSData, 32);

}  // namespace GPS
}  // namespace Sensor

namespace SPAT {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_SENDER = 6,
    VT_INTERSECTION = 8,
    VT_LANES = 10
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  double sender() const {
    return GetField<double>(VT_SENDER, 0.0);
  }
  double intersection() const {
    return GetField<double>(VT_INTERSECTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_SENDER) &&
           VerifyField<double>(verifier, VT_INTERSECTION) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_sender(double sender) {
    fbb_.AddElement<double>(State::VT_SENDER, sender, 0.0);
  }
  void add_intersection(double intersection) {
    fbb_.AddElement<double>(State::VT_INTERSECTION, intersection, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_sender(sender);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>(*lanes) : 0;
  return SynFlatBuffers::SPAT::CreateState(
      _fbb,
      time,
      sender,
      intersection,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4
  };
  SynFlatBuffers::SPAT::Color color() const {
    return static_cast<SynFlatBuffers::SPAT::Color>(GetField<int8_t>(VT_COLOR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(SynFlatBuffers::SPAT::Color color) {
    fbb_.AddElement<int8_t>(Lane::VT_COLOR, static_cast<int8_t>(color), 0);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::SPAT::Color color = SynFlatBuffers::SPAT::Color_Green) {
  LaneBuilder builder_(_fbb);
  builder_.add_color(color);
  return builder_.Finish();
}

}  // namespace SPAT

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6
  };
  const SynFlatBuffers::Vector *pos() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS);
  }
  const SynFlatBuffers::Quaternion *rot() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<SynFlatBuffers::Vector> pos) {
    fbb_.AddOffset(Pose::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot) {
    fbb_.AddOffset(Pose::VT_ROT, rot);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseBuilder &operator=(const PoseBuilder &);
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

namespace MAP {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_SENDER = 6,
    VT_INTERSECTION = 8,
    VT_LANES = 10
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  double sender() const {
    return GetField<double>(VT_SENDER, 0.0);
  }
  double intersection() const {
    return GetField<double>(VT_INTERSECTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_SENDER) &&
           VerifyField<double>(verifier, VT_INTERSECTION) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_sender(double sender) {
    fbb_.AddElement<double>(State::VT_SENDER, sender, 0.0);
  }
  void add_intersection(double intersection) {
    fbb_.AddElement<double>(State::VT_INTERSECTION, intersection, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_sender(sender);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>(*lanes) : 0;
  return SynFlatBuffers::MAP::CreateState(
      _fbb,
      time,
      sender,
      intersection,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_STOPPOS = 6,
    VT_OFFSETPOS = 8
  };
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  const SynFlatBuffers::Vector *stopPos() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_STOPPOS);
  }
  const SynFlatBuffers::Vector *offsetPos() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_OFFSETPOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_STOPPOS) &&
           verifier.VerifyTable(stopPos()) &&
           VerifyOffset(verifier, VT_OFFSETPOS) &&
           verifier.VerifyTable(offsetPos()) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(double width) {
    fbb_.AddElement<double>(Lane::VT_WIDTH, width, 0.0);
  }
  void add_stopPos(flatbuffers::Offset<SynFlatBuffers::Vector> stopPos) {
    fbb_.AddOffset(Lane::VT_STOPPOS, stopPos);
  }
  void add_offsetPos(flatbuffers::Offset<SynFlatBuffers::Vector> offsetPos) {
    fbb_.AddOffset(Lane::VT_OFFSETPOS, offsetPos);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Vector> stopPos = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> offsetPos = 0) {
  LaneBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_offsetPos(offsetPos);
  builder_.add_stopPos(stopPos);
  return builder_.Finish();
}

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_MAP = 6,
    VT_SPAT = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::MAP::State *map() const {
    return GetPointer<const SynFlatBuffers::MAP::State *>(VT_MAP);
  }
  const SynFlatBuffers::SPAT::State *spat() const {
    return GetPointer<const SynFlatBuffers::SPAT::State *>(VT_SPAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffset(verifier, VT_SPAT) &&
           verifier.VerifyTable(spat()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_map(flatbuffers::Offset<SynFlatBuffers::MAP::State> map) {
    fbb_.AddOffset(State::VT_MAP, map);
  }
  void add_spat(flatbuffers::Offset<SynFlatBuffers::SPAT::State> spat) {
    fbb_.AddOffset(State::VT_SPAT, spat);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::MAP::State> map = 0,
    flatbuffers::Offset<SynFlatBuffers::SPAT::State> spat = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_spat(spat);
  builder_.add_map(map);
  return builder_.Finish();
}

}  // namespace TrafficLight

namespace Vehicle {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_WHEELS = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_WHEELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_WHEELS) &&
           verifier.VerifyVector(wheels()) &&
           verifier.VerifyVectorOfTables(wheels()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_wheels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels) {
    fbb_.AddOffset(State::VT_WHEELS, wheels);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_wheels(wheels);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels = nullptr) {
  auto wheels__ = wheels ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*wheels) : 0;
  return SynFlatBuffers::Agent::Vehicle::CreateState(
      _fbb,
      time,
      chassis,
      wheels__);
}

}  // namespace Vehicle

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Agent::Type message_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::Vehicle::State *message_as_Vehicle_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_Vehicle_State ? static_cast<const SynFlatBuffers::Agent::Vehicle::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrafficLight::State *message_as_TrafficLight_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrafficLight_State ? static_cast<const SynFlatBuffers::Agent::TrafficLight::State *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::Vehicle::State *State::message_as<SynFlatBuffers::Agent::Vehicle::State>() const {
  return message_as_Vehicle_State();
}

template<> inline const SynFlatBuffers::Agent::TrafficLight::State *State::message_as<SynFlatBuffers::Agent::TrafficLight::State>() const {
  return message_as_TrafficLight_State();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Agent::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type message_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

}  // namespace Agent

namespace Interface {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_TYPE = 4,
    VT_STATE = 6,
    VT_TIME = 8
  };
  SynFlatBuffers::Interface::Type state_type() const {
    return static_cast<SynFlatBuffers::Interface::Type>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const SynFlatBuffers::Interface::Camera *state_as_Camera() const {
    return state_type() == SynFlatBuffers::Interface::Type_Camera ? static_cast<const SynFlatBuffers::Interface::Camera *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Lidar *state_as_Lidar() const {
    return state_type() == SynFlatBuffers::Interface::Type_Lidar ? static_cast<const SynFlatBuffers::Interface::Lidar *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::GPS *state_as_GPS() const {
    return state_type() == SynFlatBuffers::Interface::Type_GPS ? static_cast<const SynFlatBuffers::Interface::GPS *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::IMU *state_as_IMU() const {
    return state_type() == SynFlatBuffers::Interface::Type_IMU ? static_cast<const SynFlatBuffers::Interface::IMU *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Control *state_as_Control() const {
    return state_type() == SynFlatBuffers::Interface::Type_Control ? static_cast<const SynFlatBuffers::Interface::Control *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Time *state_as_Time() const {
    return state_type() == SynFlatBuffers::Interface::Type_Time ? static_cast<const SynFlatBuffers::Interface::Time *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Exit *state_as_Exit() const {
    return state_type() == SynFlatBuffers::Interface::Type_Exit ? static_cast<const SynFlatBuffers::Interface::Exit *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Time *time() const {
    return GetPointer<const SynFlatBuffers::Interface::Time *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyType(verifier, state(), state_type()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Interface::Camera *State::state_as<SynFlatBuffers::Interface::Camera>() const {
  return state_as_Camera();
}

template<> inline const SynFlatBuffers::Interface::Lidar *State::state_as<SynFlatBuffers::Interface::Lidar>() const {
  return state_as_Lidar();
}

template<> inline const SynFlatBuffers::Interface::GPS *State::state_as<SynFlatBuffers::Interface::GPS>() const {
  return state_as_GPS();
}

template<> inline const SynFlatBuffers::Interface::IMU *State::state_as<SynFlatBuffers::Interface::IMU>() const {
  return state_as_IMU();
}

template<> inline const SynFlatBuffers::Interface::Control *State::state_as<SynFlatBuffers::Interface::Control>() const {
  return state_as_Control();
}

template<> inline const SynFlatBuffers::Interface::Time *State::state_as<SynFlatBuffers::Interface::Time>() const {
  return state_as_Time();
}

template<> inline const SynFlatBuffers::Interface::Exit *State::state_as<SynFlatBuffers::Interface::Exit>() const {
  return state_as_Exit();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_type(SynFlatBuffers::Interface::Type state_type) {
    fbb_.AddElement<uint8_t>(State::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(flatbuffers::Offset<void> state) {
    fbb_.AddOffset(State::VT_STATE, state);
  }
  void add_time(flatbuffers::Offset<SynFlatBuffers::Interface::Time> time) {
    fbb_.AddOffset(State::VT_TIME, time);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Interface::Type state_type = SynFlatBuffers::Interface::Type_NONE,
    flatbuffers::Offset<void> state = 0,
    flatbuffers::Offset<SynFlatBuffers::Interface::Time> time = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  builder_.add_state_type(state_type);
  return builder_.Finish();
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_BYTES_PER_PIXEL = 8,
    VT_DATA = 10
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Camera::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Camera::VT_DATA, data);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera> CreateCameraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return SynFlatBuffers::Interface::CreateCamera(
      _fbb,
      height,
      width,
      bytes_per_pixel,
      data__);
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES_PER_PIXEL = 4,
    VT_DATA = 6
  };
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Lidar::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Lidar::VT_DATA, data);
  }
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LidarBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lidar> CreateLidarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return SynFlatBuffers::Interface::CreateLidar(
      _fbb,
      bytes_per_pixel,
      data__);
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GPSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IMUBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_BRAKING = 6,
    VT_STEERING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           verifier.EndTable();
  }
};

struct ControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(Control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(Control::VT_BRAKING, braking, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(Control::VT_STEERING, steering, 0.0f);
  }
  explicit ControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlBuilder &operator=(const ControlBuilder &);
  flatbuffers::Offset<Control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Control>(end);
    return o;
  }
};

inline flatbuffers::Offset<Control> CreateControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float braking = 0.0f,
    float steering = 0.0f) {
  ControlBuilder builder_(_fbb);
  builder_.add_steering(steering);
  builder_.add_braking(braking);
  builder_.add_throttle(throttle);
  return builder_.Finish();
}

struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(Time::VT_T, t, 0.0f);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  TimeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Exit::VT_CODE, code, 0);
  }
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0) {
  ExitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

}  // namespace Interface

namespace SCM {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIFFS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>> *diffs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>> *>(VT_DIFFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIFFS) &&
           verifier.VerifyVector(diffs()) &&
           verifier.VerifyVectorOfTables(diffs()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_diffs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>>> diffs) {
    fbb_.AddOffset(State::VT_DIFFS, diffs);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>>> diffs = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_diffs(diffs);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>> *diffs = nullptr) {
  auto diffs__ = diffs ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::SCM::Node>>(*diffs) : 0;
  return SynFlatBuffers::SCM::CreateState(
      _fbb,
      diffs__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DIFF = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const SynFlatBuffers::Vector *diff() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_DIFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_DIFF) &&
           verifier.VerifyTable(diff()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Node::VT_ID, id, 0);
  }
  void add_diff(flatbuffers::Offset<SynFlatBuffers::Vector> diff) {
    fbb_.AddOffset(Node::VT_DIFF, diff);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> diff = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_diff(diff);
  builder_.add_id(id);
  return builder_.Finish();
}

}  // namespace SCM

namespace Sensor {

struct SensorBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_BUFFER = 8
  };
  int32_t Width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t Height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *Buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(Buffer()) &&
           verifier.EndTable();
  }
};

struct SensorBufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Width(int32_t Width) {
    fbb_.AddElement<int32_t>(SensorBuffer::VT_WIDTH, Width, 0);
  }
  void add_Height(int32_t Height) {
    fbb_.AddElement<int32_t>(SensorBuffer::VT_HEIGHT, Height, 0);
  }
  void add_Buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer) {
    fbb_.AddOffset(SensorBuffer::VT_BUFFER, Buffer);
  }
  explicit SensorBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorBufferBuilder &operator=(const SensorBufferBuilder &);
  flatbuffers::Offset<SensorBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorBuffer> CreateSensorBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Width = 0,
    int32_t Height = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer = 0) {
  SensorBufferBuilder builder_(_fbb);
  builder_.add_Buffer(Buffer);
  builder_.add_Height(Height);
  builder_.add_Width(Width);
  return builder_.Finish();
}

inline flatbuffers::Offset<SensorBuffer> CreateSensorBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Width = 0,
    int32_t Height = 0,
    const std::vector<uint8_t> *Buffer = nullptr) {
  auto Buffer__ = Buffer ? _fbb.CreateVector<uint8_t>(*Buffer) : 0;
  return SynFlatBuffers::Sensor::CreateSensorBuffer(
      _fbb,
      Width,
      Height,
      Buffer__);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_TYPE = 6
  };
  const SynFlatBuffers::Sensor::SensorBuffer *buffer() const {
    return GetPointer<const SynFlatBuffers::Sensor::SensorBuffer *>(VT_BUFFER);
  }
  SynFlatBuffers::Sensor::Type type() const {
    return static_cast<SynFlatBuffers::Sensor::Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyTable(buffer()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<SynFlatBuffers::Sensor::SensorBuffer> buffer) {
    fbb_.AddOffset(State::VT_BUFFER, buffer);
  }
  void add_type(SynFlatBuffers::Sensor::Type type) {
    fbb_.AddElement<int8_t>(State::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Sensor::SensorBuffer> buffer = 0,
    SynFlatBuffers::Sensor::Type type = SynFlatBuffers::Sensor::Type_Camera_RGBA8) {
  StateBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace Sensor

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyVectorOfTables(buffer()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer) {
    fbb_.AddOffset(Buffer::VT_BUFFER, buffer);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Message>>(*buffer) : 0;
  return SynFlatBuffers::CreateBuffer(
      _fbb,
      buffer__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_ID = 8
  };
  SynFlatBuffers::Type message_type() const {
    return static_cast<SynFlatBuffers::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Pointer *message_as_Pointer() const {
    return message_type() == SynFlatBuffers::Type_Pointer ? static_cast<const SynFlatBuffers::Pointer *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::State *message_as_Agent_State() const {
    return message_type() == SynFlatBuffers::Type_Agent_State ? static_cast<const SynFlatBuffers::Agent::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Interface::State *message_as_Interface_State() const {
    return message_type() == SynFlatBuffers::Type_Interface_State ? static_cast<const SynFlatBuffers::Interface::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::SPAT::State *message_as_SPAT_State() const {
    return message_type() == SynFlatBuffers::Type_SPAT_State ? static_cast<const SynFlatBuffers::SPAT::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::MAP::State *message_as_MAP_State() const {
    return message_type() == SynFlatBuffers::Type_MAP_State ? static_cast<const SynFlatBuffers::MAP::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::SCM::State *message_as_SCM_State() const {
    return message_type() == SynFlatBuffers::Type_SCM_State ? static_cast<const SynFlatBuffers::SCM::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Sensor::State *message_as_Sensor_State() const {
    return message_type() == SynFlatBuffers::Type_Sensor_State ? static_cast<const SynFlatBuffers::Sensor::State *>(message()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Pointer *Message::message_as<SynFlatBuffers::Pointer>() const {
  return message_as_Pointer();
}

template<> inline const SynFlatBuffers::Agent::State *Message::message_as<SynFlatBuffers::Agent::State>() const {
  return message_as_Agent_State();
}

template<> inline const SynFlatBuffers::Interface::State *Message::message_as<SynFlatBuffers::Interface::State>() const {
  return message_as_Interface_State();
}

template<> inline const SynFlatBuffers::SPAT::State *Message::message_as<SynFlatBuffers::SPAT::State>() const {
  return message_as_SPAT_State();
}

template<> inline const SynFlatBuffers::MAP::State *Message::message_as<SynFlatBuffers::MAP::State>() const {
  return message_as_MAP_State();
}

template<> inline const SynFlatBuffers::SCM::State *Message::message_as<SynFlatBuffers::SCM::State>() const {
  return message_as_SCM_State();
}

template<> inline const SynFlatBuffers::Sensor::State *Message::message_as<SynFlatBuffers::Sensor::State>() const {
  return message_as_Sensor_State();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Message::VT_ID, id);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SynFlatBuffers::CreateMessage(
      _fbb,
      message_type,
      message,
      id__);
}

struct Pointer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTER = 4
  };
  const flatbuffers::Vector<uint8_t> *pointer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_POINTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTER) &&
           verifier.VerifyVector(pointer()) &&
           verifier.EndTable();
  }
};

struct PointerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pointer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pointer) {
    fbb_.AddOffset(Pointer::VT_POINTER, pointer);
  }
  explicit PointerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointerBuilder &operator=(const PointerBuilder &);
  flatbuffers::Offset<Pointer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pointer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pointer> CreatePointer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pointer = 0) {
  PointerBuilder builder_(_fbb);
  builder_.add_pointer(pointer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pointer> CreatePointerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pointer = nullptr) {
  auto pointer__ = pointer ? _fbb.CreateVector<uint8_t>(*pointer) : 0;
  return SynFlatBuffers::CreatePointer(
      _fbb,
      pointer__);
}

namespace SPAT {

}  // namespace SPAT

namespace MAP {

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

}  // namespace TrafficLight

namespace Vehicle {

}  // namespace Vehicle

}  // namespace Agent

namespace Interface {

}  // namespace Interface

namespace SCM {

}  // namespace SCM

namespace Sensor {

}  // namespace Sensor

namespace Agent {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Vehicle_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Vehicle::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrafficLight_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrafficLight::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Agent

namespace Interface {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Camera: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Interface

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Pointer: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Pointer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Agent_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Interface_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SPAT_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::SPAT::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MAP_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::MAP::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SCM_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::SCM::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Sensor_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Sensor::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const SynFlatBuffers::Buffer *GetBuffer(const void *buf) {
  return flatbuffers::GetRoot<SynFlatBuffers::Buffer>(buf);
}

inline const SynFlatBuffers::Buffer *GetSizePrefixedBuffer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SynFlatBuffers::Buffer>(buf);
}

inline bool VerifyBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline bool VerifySizePrefixedBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline void FinishBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SynFlatBuffers

#endif  // FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
